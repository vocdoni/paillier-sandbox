# Distributed Key Generation (DKG) in Go

## Introduction

This repository provides a Go implementation of a **Distributed Key Generation (DKG)** protocol using Shamir's Secret Sharing and Feldman's Verifiable Secret Sharing (VSS) over a finite field. The DKG allows multiple parties to jointly generate a shared secret key without the need for a trusted dealer. This key can then be used in threshold cryptographic schemes, such as threshold encryption or signing, where a subset of parties can perform cryptographic operations collaboratively.

### Key Features

- **Decentralized Key Generation**: No single party knows the complete secret key.
- **Threshold Security**: A minimum number of participants (threshold) is required to reconstruct the secret.
- **Verifiable Shares**: Parties can verify the correctness of the shares they receive.
- **Scalability**: Supports any number of participants and configurable threshold.

---

## How DKG Works

In a traditional cryptographic system, a secret key is generated by a single party and shared with others, which introduces a single point of failure and trust. DKG eliminates this by allowing multiple parties to collaboratively generate a shared secret key without any party knowing the entire key.

Here's how it works:

1. **Setup Phase**:
   - All parties agree on common parameters: a large prime number \( p \), a prime \( q \) where \( p = 2q + 1 \), and a generator \( g \) of a subgroup of order \( q \) in \( \mathbb{Z}_p^* \).
   - These parameters ensure that operations are secure and occur within a finite field suitable for cryptographic operations.

2. **Polynomial Generation**:
   - Each party generates a random polynomial of degree \( t-1 \) (where \( t \) is the threshold) with a **zero constant term**. The zero constant term ensures that no individual party introduces its own secret into the shared key.
   - The polynomial is of the form:
     \[
     f_i(x) = a_{i1}x + a_{i2}x^2 + \dots + a_{i(t-1)}x^{t-1} \mod q
     \]
     where \( a_{ij} \) are random coefficients.

3. **Commitment Generation**:
   - Each party computes commitments to the coefficients of their polynomial using the generator \( g \):
     \[
     C_{ij} = g^{a_{ij}} \mod p
     \]
   - These commitments are published and used for share verification.

4. **Share Distribution**:
   - Each party evaluates their polynomial at points corresponding to each participant and securely sends these **shares** to the respective parties.
     \[
     s_{ij} = f_i(j) \mod q
     \]
     where \( s_{ij} \) is the share from party \( i \) to party \( j \).

5. **Share Verification**:
   - Upon receiving shares, each party verifies them using the commitments. This ensures that the shares are consistent with the committed polynomials and haven't been tampered with.

6. **Aggregation of Shares**:
   - Each party sums the shares they received from all other parties (including their own, which is zero) to compute their **aggregate share**:
     \[
     S_j = \sum_{i=1}^{n} s_{ij} \mod q
     \]

7. **Secret Reconstruction**:
   - Any subset of at least \( t \) parties can use their aggregate shares to reconstruct the shared secret (which, in this setup, will be zero due to the zero constant terms) using Lagrange interpolation.

---

## Usage Example

Imagine a scenario where a group of servers needs to manage a cryptographic key collaboratively to decrypt messages or sign transactions, but for security reasons, no single server should have access to the complete key.

### Steps:

1. **Initialization**:
   - All servers agree on the cryptographic parameters (\( p \), \( q \), \( g \)).

2. **Key Generation**:
   - Each server runs the DKG protocol:
     - Generates a random polynomial with zero constant term.
     - Computes commitments to its polynomial coefficients.
     - Distributes shares to other servers.
     - Verifies shares received from others.

3. **Share Aggregation**:
   - Each server computes its aggregate share by summing the shares received.

4. **Using the Shared Key**:
   - When a threshold number of servers (e.g., 3 out of 5) need to perform an operation (like decrypting a message):
     - They use their aggregate shares to reconstruct the shared secret (which would be used in combination with other cryptographic operations).
     - Since the secret is zero, in practice, servers would modify the protocol to include actual secret contributions or use the shared randomness in further cryptographic computations.

### Practical Application:

- **Threshold Encryption**: A message encrypted under the shared public key can only be decrypted if a minimum number of servers collaborate.
- **Distributed Signing**: A digital signature can be produced only when a threshold number of servers participate, enhancing security in systems like blockchain consensus mechanisms.

---

## Example Using Ethereum Smart Contract for Coordination

In a decentralized application (DApp) scenario, smart contracts on platforms like Ethereum can be used to coordinate the DKG process among participants.

### Overview:

- **Smart Contract Role**:
  - Acts as a bulletin board where participants can publish commitments and shares.
  - Enforces rules and deadlines for submissions.
  - Can hold funds or rewards to incentivize honest participation.

### Steps:

1. **Deploy DKG Smart Contract**:
   - The contract defines functions for participants to submit commitments and shares.
   - Includes event logs for transparency.

2. **Participants Interact with the Contract**:

   - **Commitment Phase**:
     - Each participant generates their polynomial commitments and submits them to the contract.

   - **Share Distribution Phase**:
     - Participants compute shares for others.
     - Instead of directly sending shares (which need to be kept secret), participants may encrypt shares using the recipient's public key and publish the ciphertext on the contract or off-chain storage with a reference in the contract.

   - **Verification Phase**:
     - Participants retrieve their shares, decrypt them, and verify using the commitments published on-chain.

3. **Aggregation and Reconstruction**:

   - After successful verification, participants compute their aggregate shares.
   - Reconstruction of the secret happens off-chain among the subset of participants when needed.

### Considerations:

- **Security**: Sensitive data like shares should not be published in plaintext on-chain.
- **Gas Costs**: On-chain operations incur costs; thus, data storage should be minimized.
- **Incentives and Penalties**: The contract can include mechanisms to penalize misbehavior or reward correct participation.

### Example Code Snippet (Pseudo-code):

```solidity
contract DKG {
    struct Commitment {
        address participant;
        uint256[] commitments;
    }

    mapping(address => Commitment) public commitments;

    event CommitmentSubmitted(address indexed participant);
    event ShareEncrypted(address indexed from, address indexed to, bytes encryptedShare);

    function submitCommitment(uint256[] memory _commitments) public {
        commitments[msg.sender] = Commitment(msg.sender, _commitments);
        emit CommitmentSubmitted(msg.sender);
    }

    function submitEncryptedShare(address _to, bytes memory _encryptedShare) public {
        // Store or log the encrypted share
        emit ShareEncrypted(msg.sender, _to, _encryptedShare);
    }

    // Additional functions for coordination...
}
```

Participants would interact with this contract during the DKG process, ensuring transparency and coordination without relying on a central authority.

---

## Mathematical Explanation and Security Justification

### Shamir's Secret Sharing

- **Concept**: A secret \( S \) can be divided into \( n \) shares, with a threshold \( t \), such that any \( t \) shares can reconstruct \( S \), but any fewer cannot.
- **Polynomial**: A random polynomial \( f(x) \) of degree \( t - 1 \) is constructed with the secret as the constant term (\( f(0) = S \)).

### Feldman's Verifiable Secret Sharing (VSS)

- **Purpose**: Enhances Shamir's scheme by allowing verification of shares without revealing the secret.
- **Commitments**: Participants publish commitments to the polynomial coefficients using a generator \( g \):
  \[
  C_j = g^{a_j} \mod p
  \]
- **Verification**: Other participants can verify shares \( s_i \) using the commitments.

### DKG Protocol Steps

1. **Parameter Generation**:
   - Choose large primes \( p \) and \( q \), with \( p = 2q + 1 \).
   - Select a generator \( g \) of the subgroup of order \( q \) in \( \mathbb{Z}_p^* \).

2. **Polynomial Generation**:
   - Each participant \( i \) generates a random polynomial \( f_i(x) \) of degree \( t - 1 \) with zero constant term:
     \[
     f_i(x) = a_{i1}x + a_{i2}x^2 + \dots + a_{i(t-1)}x^{t-1} \mod q
     \]
   - Zero constant term ensures that the individual polynomials don't introduce personal secrets.

3. **Commitment Computation**:
   - For each coefficient \( a_{ij} \), compute:
     \[
     C_{ij} = g^{a_{ij}} \mod p
     \]
   - Publish \( C_{ij} \) to allow others to verify shares.

4. **Share Distribution**:
   - Each participant computes shares for others:
     \[
     s_{ij} = f_i(j) \mod q
     \]
   - Shares are securely sent to the corresponding participants.

5. **Share Verification**:
   - Upon receiving \( s_{ji} \) from participant \( j \), participant \( i \) verifies:
     \[
     g^{s_{ji}} \mod p = \prod_{k=1}^{t-1} C_{jk}^{i^k} \mod p
     \]
   - This equation ensures that the share corresponds to the committed polynomial.

6. **Aggregate Share Computation**:
   - Each participant sums all received shares (including their own zero share):
     \[
     S_i = \sum_{j=1}^{n} s_{ji} \mod q
     \]

7. **Secret Reconstruction**:
   - Any subset \( T \) of at least \( t \) participants can reconstruct the secret using their aggregate shares and Lagrange interpolation:
     \[
     S = \sum_{i \in T} S_i \cdot \lambda_i \mod q
     \]
     where \( \lambda_i \) are Lagrange coefficients:
     \[
     \lambda_i = \prod_{j \in T, j \ne i} \frac{-x_j}{x_i - x_j} \mod q
     \]
     and \( x_i \) is the index of participant \( i \).

### Security Justification

- **Threshold Security**: Fewer than \( t \) participants cannot reconstruct the secret because they lack sufficient information to solve for the polynomial coefficients.
- **Verifiability**: Commitments allow participants to verify shares, preventing malicious actors from introducing invalid data.
- **Zero Knowledge**: The commitments and verification process do not reveal any information about the secret or the polynomial coefficients.
- **Distributed Trust**: Since no single participant knows the entire secret, trust is distributed among the group.

---

## Potential Threats and Vulnerabilities

1. **Malicious Participants**:
   - **Issue**: Participants may send invalid shares or commitments.
   - **Mitigation**: Share verification using commitments helps detect invalid shares. Additional cryptographic proofs (e.g., Zero-Knowledge Proofs) can enhance security.

2. **Collusion**:
   - **Issue**: A group of less than \( t \) malicious participants may attempt to reconstruct partial information.
   - **Mitigation**: The mathematical properties of Shamir's scheme ensure that fewer than \( t \) shares provide no information about the secret.

3. **Denial of Service (DoS)**:
   - **Issue**: Participants may refuse to send shares or commitments, hindering the protocol.
   - **Mitigation**: Implement timeouts and penalties (e.g., via smart contracts) for non-cooperative behavior.

4. **Replay Attacks**:
   - **Issue**: An adversary may attempt to reuse old shares or commitments.
   - **Mitigation**: Include session identifiers or timestamps to ensure freshness of data.

5. **Randomness Quality**:
   - **Issue**: Poor randomness can weaken security, making it easier to predict polynomial coefficients.
   - **Mitigation**: Use cryptographically secure random number generators.

6. **Communication Security**:
   - **Issue**: Intercepted shares may be exposed if sent over insecure channels.
   - **Mitigation**: Encrypt shares when transmitting them between participants.

7. **Smart Contract Vulnerabilities** (if used):
   - **Issue**: Bugs in smart contract code may be exploited.
   - **Mitigation**: Conduct thorough audits and testing of smart contracts.

8. **Parameter Tampering**:
   - **Issue**: Participants may use different parameters \( p \), \( q \), or \( g \).
   - **Mitigation**: Agree on parameters beforehand and verify them during the protocol.

---

## Usage Examples

### Basic Example

```go
package main

import (
    "fmt"
    "math/big"
    "dkg"
)

func main() {
    // Parameters
    bits := 512
    q, p := dkg.GenerateSafePrime(bits)
    g := dkg.FindGenerator(p, q)
    k := 3           // Threshold
    nParties := 5    // Number of parties

    // Each party generates its polynomial and commitments
    polynomials := make([][]*big.Int, nParties)
    commitments := make([][]*big.Int, nParties)

    for i := 0; i < nParties; i++ {
        polynomials[i] = dkg.GeneratePolynomial(k, q)
        commitments[i] = dkg.GenerateCommitments(polynomials[i], g, p)
    }

    // Each party generates shares for all other parties
    shares := make([][]*big.Int, nParties) // shares[i][j]: share from party i to party j
    for i := 0; i < nParties; i++ {
        shares[i] = make([]*big.Int, nParties)
        for j := 0; j < nParties; j++ {
            shares[i][j] = dkg.GenerateShare(j+1, polynomials[i], q)
        }
    }

    // Each party verifies shares and computes aggregate shares
    aggregatedShares := make([]*big.Int, nParties)
    for i := 0; i < nParties; i++ {
        aggregatedShares[i] = big.NewInt(0)
        for j := 0; j < nParties; j++ {
            // Verify share from party j
            valid := dkg.VerifyShare(shares[j][i], i+1, commitments[j], g, p)
            if !valid {
                fmt.Printf("Share verification failed for party %d's share from party %d\n", i+1, j+1)
                return
            }
            aggregatedShares[i].Add(aggregatedShares[i], shares[j][i]).Mod(aggregatedShares[i], q)
        }
    }

    // Reconstruct the secret using any k aggregate shares
    indices := []int{1, 2, 3}
    subsetShares := []*big.Int{
        aggregatedShares[0],
        aggregatedShares[1],
        aggregatedShares[2],
    }
    secret := dkg.LagrangeInterpolation(subsetShares, indices, q)
    fmt.Printf("Reconstructed secret: %s\n", secret.String())
}
```

---

## References

- **Shamir's Secret Sharing**: A method for sharing a secret among a group of participants.
- **Feldman's Verifiable Secret Sharing**: An extension of Shamir's scheme that allows for share verification.
- **Distributed Key Generation (DKG)**: A protocol for generating shared keys without a trusted dealer.

---

## License

This project is licensed under the AGPLv3 License.

---

Feel free to contribute, raise issues, or suggest enhancements!